- name: "Import {{ item.name }} GPG key"
  apt_key:
    url: "{{ item.gpg_url }}"
    state: present
  when: (item.gpg_url is defined) and (ansible_distribution == 'Ubuntu')

- name: "Import {{ item.name }} GPG key"
  rpm_key:
    key: "{{ item.gpg_url }}"
    state: present
  when: (item.gpg_url is defined) and (ansible_distribution == 'CentOS' or ansible_distribution == 'RedHat')

- name: "Import {{ item.name }} GPG key"
  apt_key:
    keyserver: "{{ item.gpg_server }}"
    id: "{{ item.gpg_id }}"
    state: present
  when: (item.gpg_server is defined) and (item.gpg_id is defined) and (ansible_distribution == 'Ubuntu')

- name: "Import {{ item.name }} GPG key"
  apt_key:
    data: "{{ lookup('file', '{{ item.gpg_file }}.asc') }}"
    state: present
  when: item.gpg_file is defined

- name: "Add {{ item.name }} repo"
  template:
    src: "{{ item.repo_file }}.list.j2"
    dest: "/etc/apt/sources.list.d/{{ item.repo_file }}.list"
  when: ansible_distribution == 'Ubuntu'

- name: "Add {{ item.name }} repo"
  template:
    src: "{{ item.repo_file }}.repo.j2"
    dest: "/etc/yum.repos.d/{{ item.repo_file }}.repo"
  when: (ansible_distribution == 'CentOS' or ansible_distribution == 'RedHat')

# use inline jinja conditional instead of when: so that
# thirdparty_conflict is always defined for the next step
- name: Check if conflicting packages are installed
  shell: "{% if item.except is defined%}apt list --installed | grep \"{{ item.except }}/\"{% else %}false{% endif %}"
  ignore_errors: yes
  changed_when: no
  no_log: True
  register: thirdparty_conflict
  when: ansible_distribution == 'Ubuntu'

# if version is undefined, unhold to ensure the latest is installed
# rc = 100 when 'Unable to locate package' = not installed yet
- name: "Unhold {{ item.package }}"
  command: "apt-mark unhold {{ item.package }}"
  register: 3rdparty_unhold
  changed_when: ('was already not hold.' not in 3rdparty_unhold.stdout)
  failed_when: (3rdparty_unhold.rc != 0) and (3rdparty_unhold.rc != 100)
  when: (ansible_distribution == 'Ubuntu') and (item.version is not defined)

# allow upgrades from one specified version to another, but not downgrades
- name: "Unhold {{ item.package }}"
  shell: "apt install --simulate {{ item.package }}={{ item.version }} | grep 'The following packages will be upgraded' && apt-mark unhold {{ item.package }}"
  ignore_errors: yes
  no_log: True
  register: 3rdparty_unhold2
  changed_when: 3rdparty_unhold2.rc == 0
  when: (ansible_distribution == 'Ubuntu') and (item.version is defined)

- name: "Install {{ item.name }}"
  apt:
    name: "{{ item.package }}{% if item.version is defined and item.version | length > 0 %}={{ item.version }}{% endif %}"
    state: "{% if item.version is defined and item.version | length > 0 %}present{% else %}latest{% endif %}"
    update_cache: yes
    install_recommends: "{{ item.install_recommends | default('yes') }}"
  register: app_install
  when: (ansible_distribution == 'Ubuntu') and (item.package is defined) and (thirdparty_conflict.rc != 0)

- name: "Install {{ item.name }}"
  yum:
    name: "{{ item.package }}"
    state: "{% if item.version is defined and item.version | length > 0 %}present{% else %}latest{% endif %}"
  register: app_install
  when: (ansible_distribution == 'CentOS' or ansible_distribution == 'RedHat') and (item.package is defined)

- name: "Hold {{ item.package }}"
  command: "apt-mark hold {{ item.package }}"
  register: 3rdparty_hold
  changed_when: ('was already set on hold.' not in 3rdparty_hold.stdout)
  when: (ansible_distribution == 'Ubuntu') and (item.version is defined)

# enforce upgrade if the repo provides a newer version of an Ubuntu package
# e.g. PostgreSQL's libpq/libgeos packages
- name: Update all packages
  apt:
    upgrade: dist
    update_cache: no
  when: ansible_distribution == 'Ubuntu'

# remove the superseded Ubuntu packages
- name: Remove obsolete packages
  apt:
    autoremove: yes
  when: ansible_distribution == 'Ubuntu'

# installing the package adds noise to the repo file in postinst, fix it
- name: "Fix {{ item.name }} repo file"
  template:
    src: "{{ item.repo_file }}.list.j2"
    dest: "/etc/apt/sources.list.d/{{ item.repo_file }}.list"
  when: (app_install.changed) and (item.repo_overwrite is defined) and (item.repo_overwrite == True) and (ansible_distribution == 'Ubuntu')

- name: Run ldconfig
  command: ldconfig
  when: app_install.changed and item.ldconfig is defined and item.ldconfig == True
